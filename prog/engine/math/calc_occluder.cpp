// Copyright (C) Gaijin Games KFT.  All rights reserved.

#include <math/dag_TMatrix.h>
#include <math/dag_plane3.h>
#include <math/dag_Point3.h>
#include <math/dag_bounds3.h>
#include <vecmath/dag_vecMath.h>
#include <math/dag_occluder.h>
#include <util/dag_globDef.h>
#include <math/dag_Point4.h>
#include <math/dag_vecMathCompatibility.h>

// Copy+Pasted from math3d.cpp
// static const int SNaNint=0xFFBFFFFF;
// const float realSNaN=*(float*)&SNaNint;

//--------------------------------------------------------------------------------------

#define CALC_FRUSTUM_EPS_THRESHOLD 0.0001f

#if DAGOR_DBGLEVEL > 0
static inline bool almost_zero(float f)
{
  // is_equal_float and etc. from dag_mathBase.h are operating with floats through an int pointer, it might not be fine for all
  // platfroms. Couldn't find what would be good for this.
  return fabsf(f) < CALC_FRUSTUM_EPS_THRESHOLD;
}

static inline bool almost_equal(float a, float b) { return almost_zero(a - b); }

static inline bool is_near_plane(const Point3 &point, const Plane3 &plane)
{
  // Might not work well for non-normalized planes with ultra-small/ultra-large values of n, d.
  // In this case, the speed is preferred over additional normalization.
  return almost_zero(plane.distance(point));
}
#endif

//--------------------------------------------------------------------------------------
//      frustum_for_box_occluder and assisting functions.
//--------------------------------------------------------------------------------------

static inline unsigned unit_segment_classify(float x)
{
  // It can be done this way. Finding better solutions would require measuring for specific compilers/platforms.
  //
  // int x_as_int = *(int*)&x;
  // return (2+((x_as_int-0x3f800000) >> 31)) & (~x_as_int >> 31);
  //

  if (x < -.5f)
    return 0;
  if (x < .5f)
    return 1;
  return 2;
}

static inline bool likely_inside_m0505(float x)
{
  return (-CALC_FRUSTUM_EPS_THRESHOLD - 0.5f < x) && (x < 0.5f + CALC_FRUSTUM_EPS_THRESHOLD);
}

struct BoxPointClassificationForOcclusion
{
  int mFrontPlane[3];
  int mSidePlanesCount;
  int mSidePlanes[BOX_OCCLUDER_PLANES_MAX - 1][2];
};


// This table was generated by gen_frustum_planes_table.py script.
// Three-dimensional array, [the position of a point relative to [-.5 .. .5] (three variants)]^3  -> which planes should be used.
static const BoxPointClassificationForOcclusion gBoxPointClassificationForOcclusion[3 * 3 * 3] = {
  {{3, 6, 5}, 6, {{4, 5}, {5, 1}, {1, 3}, {3, 2}, {2, 6}, {6, 4}}},
  {{4, 5, 3}, 6, {{5, 1}, {1, 3}, {3, 2}, {2, 0}, {0, 4}, {4, 5}}},
  {{7, 2, 4}, 6, {{0, 4}, {4, 5}, {5, 7}, {7, 3}, {3, 2}, {2, 0}}},
  {{6, 4, 1}, 6, {{4, 0}, {0, 1}, {1, 3}, {3, 2}, {2, 6}, {6, 4}}},
  {{3, 2, 1}, 4, {{3, 2}, {2, 0}, {0, 1}, {1, 3}}},
  {{5, 7, 2}, 6, {{7, 3}, {3, 2}, {2, 0}, {0, 1}, {1, 5}, {5, 7}}},
  {{7, 4, 1}, 6, {{0, 1}, {1, 3}, {3, 7}, {7, 6}, {6, 4}, {4, 0}}},
  {{7, 6, 0}, 6, {{6, 2}, {2, 0}, {0, 1}, {1, 3}, {3, 7}, {7, 6}}},
  {{5, 6, 0}, 6, {{2, 0}, {0, 1}, {1, 5}, {5, 7}, {7, 6}, {6, 2}}},
  {{5, 1, 2}, 6, {{1, 0}, {0, 2}, {2, 6}, {6, 4}, {4, 5}, {5, 1}}},
  {{0, 4, 1}, 4, {{0, 4}, {4, 5}, {5, 1}, {1, 0}}},
  {{0, 4, 7}, 6, {{4, 5}, {5, 7}, {7, 3}, {3, 1}, {1, 0}, {0, 4}}},
  {{4, 0, 6}, 4, {{4, 0}, {0, 2}, {2, 6}, {6, 4}}},
  {{0, 2, 1}, 0, {}},
  {{5, 7, 1}, 4, {{5, 7}, {7, 3}, {3, 1}, {1, 5}}},
  {{3, 7, 4}, 6, {{7, 6}, {6, 4}, {4, 0}, {0, 2}, {2, 3}, {3, 7}}},
  {{7, 6, 3}, 4, {{7, 6}, {6, 2}, {2, 3}, {3, 7}}},
  {{1, 5, 6}, 6, {{5, 7}, {7, 6}, {6, 2}, {2, 3}, {3, 1}, {1, 5}}},
  {{1, 2, 7}, 6, {{6, 7}, {7, 5}, {5, 1}, {1, 0}, {0, 2}, {2, 6}}},
  {{1, 0, 6}, 6, {{0, 4}, {4, 6}, {6, 7}, {7, 5}, {5, 1}, {1, 0}}},
  {{0, 6, 3}, 6, {{7, 3}, {3, 1}, {1, 0}, {0, 4}, {4, 6}, {6, 7}}},
  {{7, 5, 0}, 6, {{5, 4}, {4, 0}, {0, 2}, {2, 6}, {6, 7}, {7, 5}}},
  {{5, 4, 7}, 4, {{5, 4}, {4, 6}, {6, 7}, {7, 5}}},
  {{4, 6, 3}, 6, {{6, 7}, {7, 3}, {3, 1}, {1, 5}, {5, 4}, {4, 6}}},
  {{5, 0, 3}, 6, {{2, 3}, {3, 7}, {7, 5}, {5, 4}, {4, 0}, {0, 2}}},
  {{5, 4, 2}, 6, {{4, 6}, {6, 2}, {2, 3}, {3, 7}, {7, 5}, {5, 4}}},
  {{4, 2, 1}, 6, {{3, 1}, {1, 5}, {5, 4}, {4, 6}, {6, 2}, {2, 3}}},
};

// These tables were generated by gen_near_cube_table.py script
static const int gNearCubeFrontPlaneForOcclusion[2][2][2][2] = {
  14,
  14,
  14,
  12,
  22,
  4,
  14,
  12,
  16,
  10,
  16,
  10,
  22,
  4,
  14,
  14,
};
static const int gComparisonsToMaxCoordIndex[2][2][2] = {
  0,
  0,
  2,
  0,
  1,
  1,
  2,
  0,
};

void frustum_for_box_occluder(const TMatrix &to_box_space, const Point3 box_corners[8], const Point3 &eye,
  plane3f out_frustum_planes[BOX_OCCLUDER_PLANES_MAX], int *out_planes_count)
{
  Point3 box_eye = to_box_space * eye;

  G_ASSERT(to_box_space.det() > 0);

  unsigned index = unit_segment_classify(box_eye.x) * 1 + unit_segment_classify(box_eye.y) * 3 + unit_segment_classify(box_eye.z) * 9;
  G_ASSERT(index < 27);

  {
    // Rare case near_box, when the point is located very close to the cube.
    // Then the plane is chosen based on the closest face to the eye.
    bool near_box = likely_inside_m0505(box_eye.x) && likely_inside_m0505(box_eye.y) && likely_inside_m0505(box_eye.z);
    if (near_box)
    {
      float abs_x = fabsf(box_eye.x), abs_y = fabsf(box_eye.y), abs_z = fabsf(box_eye.z);
      int i0 = abs_x < abs_y, i1 = abs_y < abs_z, i2 = abs_z < abs_x;

      float max_coord = box_eye[gComparisonsToMaxCoordIndex[i0][i1][i2]];
      const BoxPointClassificationForOcclusion &cl =
        gBoxPointClassificationForOcclusion[gNearCubeFrontPlaneForOcclusion[i0][i1][i2][max_coord < 0]];

      *out_planes_count = 1;
      Plane3 p(box_corners[cl.mFrontPlane[0]], box_corners[cl.mFrontPlane[1]], box_corners[cl.mFrontPlane[2]]);
      out_frustum_planes[0] = v_ldu(&p.n.x);
      return;
    }
  }

  {
    // Common case. Planes are constructed based on index, obtained from unit_segment_classify for x,y,z.
    const BoxPointClassificationForOcclusion &cl = gBoxPointClassificationForOcclusion[index];
    *out_planes_count = cl.mSidePlanesCount + 1;
    Plane3 p(box_corners[cl.mFrontPlane[0]], box_corners[cl.mFrontPlane[1]], box_corners[cl.mFrontPlane[2]]);
    out_frustum_planes[0] = v_ldu(&p.n.x);
    for (int i = 0; i < cl.mSidePlanesCount; ++i)
    {
      Plane3 p_(Plane3(eye, box_corners[cl.mSidePlanes[i][0]], box_corners[cl.mSidePlanes[i][1]]));
      out_frustum_planes[i + 1] = v_ldu(&p_.n.x);
    }
  }
}

//--------------------------------------------------------------------------------------

bool frustum_for_4p_occluder(const Point3 occluder[4], const Plane3 &plane, const Point3 &eye, plane3f out_frustum_planes[5])
{
  const Point3 *oc = occluder;

#if DAGOR_DBGLEVEL > 0
  G_ASSERT(is_near_plane(oc[3], plane) && "frustum_for_4p_occluder: four points are not a plane quad");
  G_ASSERT(almost_equal(plane.n.lengthSq(), 1.f));

  Plane3 test_plane(oc[0], oc[1], oc[2]);
  test_plane.normalize();
  // Check for the correspondence of occluder and plane
  G_ASSERT(almost_zero((test_plane.n - plane.n).lengthSq()));

  // Check for having a convex qudrilateral (or that the vertices are correct).
  static int other_triples[3][3] = {{0, 1, 3}, {1, 3, 2}, {3, 2, 0}};
  for (int ti = 0; ti < 3; ++ti)
  {
    Plane3 other_plane(oc[other_triples[ti][0]], oc[other_triples[ti][1]], oc[other_triples[ti][2]]);
    // Normal should be oriented in the same direction
    G_ASSERT(other_plane.n * plane.n > -CALC_FRUSTUM_EPS_THRESHOLD && "frustum_for_4p_occluder: four points are not convex quad");
  }
#endif

  float plane_eye_dist = plane.distance(eye); // Normal of the quadrilateral is directed either to or from the eye (signed distance).
  Plane3 planes[5];
  planes[0] = plane;
  planes[1].set(eye, oc[0], oc[1]);
  planes[2].set(eye, oc[1], oc[3]);
  planes[3].set(eye, oc[3], oc[2]);
  planes[4].set(eye, oc[2], oc[0]);

  if (plane_eye_dist > CALC_FRUSTUM_EPS_THRESHOLD)
  {
    for (int i = 0; i < 5; ++i)
      planes[i].flip();
  }
  else if (plane_eye_dist > -CALC_FRUSTUM_EPS_THRESHOLD)
  {
    // for (int i = 0; i < 5; ++i)
    //     out_frustum_planes[i].set(realSNaN, realSNaN, realSNaN, realSNaN);
    return false;
  }
  for (int i = 0; i < 5; ++i)
    out_frustum_planes[i] = v_ldu(&planes[i].n.x);

  return true;
}

//--------------------------------------------------------------------------------------
//      is_*_occluded and assisting functions.
//--------------------------------------------------------------------------------------


static __forceinline Point3 get_box_corner(const BBox3 &box, int corner_index) { return box.point(corner_index); }

static __forceinline bool is_box_in_half_space(const BBox3 &box, const Plane3 frustum_plane,
  const int box_corner_index_for_plane_testing)
{
  Point3 corner = get_box_corner(box, box_corner_index_for_plane_testing);
  return frustum_plane.distance(corner) >= 0;
}


bool is_box_occluded(const BBox3 &box, const Plane3 frustum_planes[], const char box_corner_indices_for_plane_testing[],
  int planes_count)
{
  for (int i = 0; i < planes_count; ++i)
    if (!is_box_in_half_space(box, frustum_planes[i], box_corner_indices_for_plane_testing[i]))
      return false;
  return true;
}

bool is_sphere_occluded(const BSphere3 &sphere, const Plane3 *frustum_planes, int planes_count)
{
  for (int i = 0; i < planes_count; ++i)
  {
    const Plane3 &plane = frustum_planes[i];
    float d = frustum_planes[i].distance(sphere.c);
    if (d < 0 || d * d < sphere.r2 * plane.n.lengthSq())
      return false;
  }
  return true;
}
