//
// Dagor Engine 6.5 - Game Libraries
// Copyright (C) Gaijin Games KFT.  All rights reserved.
//
#pragma once

// Auto Generated File, Generated By spirv/gen_traits.py

#include "traits_table_base.h"
// temporary hack for value named as type i.e. struct a#Tag { a b; } a;
typedef spirv::FPRoundingMode FPRoundingModeValue;

namespace spirv
{
enum class Extension
{
  KHR_ray_query = 0,
  KHR_multiview = 1,
  INTEL_optnone = 2,
  AMD_gcn_shader = 3,
  INTEL_fpga_reg = 4,
  NV_mesh_shader = 5,
  NV_ray_tracing = 6,
  INTEL_io_pipes = 7,
  INTEL_loop_fuse = 8,
  KHR_ray_tracing = 9,
  INTEL_subgroups = 10,
  NV_shading_rate = 11,
  KHR_linkonce_odr = 12,
  KHR_device_group = 13,
  GOOGLE_user_type = 14,
  KHR_8bit_storage = 15,
  KHR_shader_clock = 16,
  KHR_subgroup_vote = 17,
  AMD_shader_ballot = 18,
  KHR_expect_assume = 19,
  KHR_16bit_storage = 20,
  KHR_shader_ballot = 21,
  NV_viewport_array2 = 22,
  INTEL_debug_module = 23,
  KHR_float_controls = 24,
  NV_bindless_texture = 25,
  INTEL_media_block_io = 26,
  INTEL_vector_compute = 27,
  KHR_bit_instructions = 28,
  INTEL_blocking_pipes = 29,
  INTEL_float_controls2 = 30,
  INTEL_inline_assembly = 31,
  NV_shader_sm_builtins = 32,
  NV_cooperative_matrix = 33,
  KHR_variable_pointers = 34,
  EXT_shader_image_int64 = 35,
  GOOGLE_decorate_string = 36,
  EXT_descriptor_indexing = 37,
  KHR_integer_dot_product = 38,
  INTEL_function_pointers = 39,
  KHR_vulkan_memory_model = 40,
  INTEL_kernel_attributes = 41,
  KHR_post_depth_coverage = 42,
  INTEL_fp_fast_math_mode = 43,
  NV_stereo_view_rendering = 44,
  AMD_shader_fragment_mask = 45,
  KHR_terminate_invocation = 46,
  INTEL_fpga_loop_controls = 47,
  KHR_fragment_shading_rate = 48,
  AMD_shader_trinary_minmax = 49,
  EXT_shader_stencil_export = 50,
  INTEL_usm_storage_classes = 51,
  NV_shader_image_footprint = 52,
  NV_ray_tracing_motion_blur = 53,
  INTEL_fpga_memory_accesses = 54,
  INTEL_fpga_buffer_location = 55,
  KHR_shader_draw_parameters = 56,
  GOOGLE_hlsl_functionality1 = 57,
  EXT_fragment_fully_covered = 58,
  EXT_shader_atomic_float_add = 59,
  AMD_texture_gather_bias_lod = 60,
  INTEL_variable_length_array = 61,
  KHR_physical_storage_buffer = 62,
  EXT_physical_storage_buffer = 63,
  INTEL_fpga_memory_attributes = 64,
  INTEL_long_constant_composite = 65,
  INTEL_fpga_cluster_attributes = 66,
  EXT_shader_atomic_float16_add = 67,
  NV_compute_shader_derivatives = 68,
  EXT_fragment_shader_interlock = 69,
  KHR_shader_atomic_counter_ops = 70,
  KHR_no_integer_wrap_decoration = 71,
  NV_geometry_shader_passthrough = 72,
  NV_shader_subgroup_partitioned = 73,
  NV_fragment_shader_barycentric = 74,
  AMD_shader_image_load_store_lod = 75,
  AMD_gpu_shader_half_float_fetch = 76,
  EXT_demote_to_helper_invocation = 77,
  KHR_fragment_shader_barycentric = 78,
  EXT_fragment_invocation_density = 79,
  INTEL_shader_integer_functions2 = 80,
  EXT_shader_viewport_index_layer = 81,
  EXT_shader_atomic_float_min_max = 82,
  NV_sample_mask_override_coverage = 83,
  KHR_storage_buffer_storage_class = 84,
  INTEL_unstructured_loop_controls = 85,
  NVX_multiview_per_view_attributes = 86,
  KHR_subgroup_uniform_control_flow = 87,
  INTEL_arbitrary_precision_integers = 88,
  KHR_workgroup_memory_explicit_layout = 89,
  AMD_shader_explicit_vertex_parameter = 90,
  INTEL_arbitrary_precision_fixed_point = 91,
  INTEL_device_side_avc_motion_estimation = 92,
  INTEL_arbitrary_precision_floating_point = 93,
  Count
};
enum class ExtendedGrammar
{
  GLSL_std_450 = 0,
  AMD_gcn_shader = 1,
  AMD_shader_ballot = 2,
  AMD_shader_trinary_minmax = 3,
  AMD_shader_explicit_vertex_parameter = 4,
  Count
};
// extension and extended grammar names to internal id translation
Extension extension_name_to_id(const char *name, Id name_len);
dag::ConstSpan<char> extension_id_to_name(Extension ident);
ExtendedGrammar extended_grammar_name_to_id(const char *name, Id name_len);
dag::ConstSpan<char> extended_grammar_id_to_name(ExtendedGrammar ident);
// extended grammar opcodes
enum class GLSLstd450 : unsigned
{
  Round = 1,
  RoundEven = 2,
  Trunc = 3,
  FAbs = 4,
  SAbs = 5,
  FSign = 6,
  SSign = 7,
  Floor = 8,
  Ceil = 9,
  Fract = 10,
  Radians = 11,
  Degrees = 12,
  Sin = 13,
  Cos = 14,
  Tan = 15,
  Asin = 16,
  Acos = 17,
  Atan = 18,
  Sinh = 19,
  Cosh = 20,
  Tanh = 21,
  Asinh = 22,
  Acosh = 23,
  Atanh = 24,
  Atan2 = 25,
  Pow = 26,
  Exp = 27,
  Log = 28,
  Exp2 = 29,
  Log2 = 30,
  Sqrt = 31,
  InverseSqrt = 32,
  Determinant = 33,
  MatrixInverse = 34,
  Modf = 35,
  ModfStruct = 36,
  FMin = 37,
  UMin = 38,
  SMin = 39,
  FMax = 40,
  UMax = 41,
  SMax = 42,
  FClamp = 43,
  UClamp = 44,
  SClamp = 45,
  FMix = 46,
  IMix = 47,
  Step = 48,
  SmoothStep = 49,
  Fma = 50,
  Frexp = 51,
  FrexpStruct = 52,
  Ldexp = 53,
  PackSnorm4x8 = 54,
  PackUnorm4x8 = 55,
  PackSnorm2x16 = 56,
  PackUnorm2x16 = 57,
  PackHalf2x16 = 58,
  PackDouble2x32 = 59,
  UnpackSnorm2x16 = 60,
  UnpackUnorm2x16 = 61,
  UnpackHalf2x16 = 62,
  UnpackSnorm4x8 = 63,
  UnpackUnorm4x8 = 64,
  UnpackDouble2x32 = 65,
  Length = 66,
  Distance = 67,
  Cross = 68,
  Normalize = 69,
  FaceForward = 70,
  Reflect = 71,
  Refract = 72,
  FindILsb = 73,
  FindSMsb = 74,
  FindUMsb = 75,
  InterpolateAtCentroid = 76,
  InterpolateAtSample = 77,
  InterpolateAtOffset = 78,
  NMin = 79,
  NMax = 80,
  NClamp = 81
};
enum class AMDGcnShader : unsigned
{
  CubeFaceIndexAMD = 1,
  CubeFaceCoordAMD = 2,
  TimeAMD = 3
};
enum class AMDShaderBallot : unsigned
{
  SwizzleInvocationsAMD = 1,
  SwizzleInvocationsMaskedAMD = 2,
  WriteInvocationAMD = 3,
  MbcntAMD = 4
};
enum class AMDShaderTrinaryMinmax : unsigned
{
  FMin3AMD = 1,
  UMin3AMD = 2,
  SMin3AMD = 3,
  FMax3AMD = 4,
  UMax3AMD = 5,
  SMax3AMD = 6,
  FMid3AMD = 7,
  UMid3AMD = 8,
  SMid3AMD = 9
};
enum class AMDShaderExplicitVertexParameter : unsigned
{
  InterpolateAtVertexAMD = 1
};
// extended grammar enum types
inline MemorySemanticsMask operator&(MemorySemanticsMask a, MemorySemanticsMask b)
{
  return MemorySemanticsMask(unsigned(a) & unsigned(b));
}
inline MemorySemanticsMask operator^(MemorySemanticsMask a, MemorySemanticsMask b)
{
  return MemorySemanticsMask(unsigned(a) ^ unsigned(b));
}
inline SelectionControlMask operator&(SelectionControlMask a, SelectionControlMask b)
{
  return SelectionControlMask(unsigned(a) & unsigned(b));
}
inline SelectionControlMask operator^(SelectionControlMask a, SelectionControlMask b)
{
  return SelectionControlMask(unsigned(a) ^ unsigned(b));
}
inline LoopControlMask operator&(LoopControlMask a, LoopControlMask b) { return LoopControlMask(unsigned(a) & unsigned(b)); }
inline LoopControlMask operator^(LoopControlMask a, LoopControlMask b) { return LoopControlMask(unsigned(a) ^ unsigned(b)); }
inline RayFlagsMask operator&(RayFlagsMask a, RayFlagsMask b) { return RayFlagsMask(unsigned(a) & unsigned(b)); }
inline RayFlagsMask operator^(RayFlagsMask a, RayFlagsMask b) { return RayFlagsMask(unsigned(a) ^ unsigned(b)); }
inline FragmentShadingRateMask operator&(FragmentShadingRateMask a, FragmentShadingRateMask b)
{
  return FragmentShadingRateMask(unsigned(a) & unsigned(b));
}
inline FragmentShadingRateMask operator^(FragmentShadingRateMask a, FragmentShadingRateMask b)
{
  return FragmentShadingRateMask(unsigned(a) ^ unsigned(b));
}
inline FunctionControlMask operator&(FunctionControlMask a, FunctionControlMask b)
{
  return FunctionControlMask(unsigned(a) & unsigned(b));
}
inline FunctionControlMask operator^(FunctionControlMask a, FunctionControlMask b)
{
  return FunctionControlMask(unsigned(a) ^ unsigned(b));
}
inline ImageOperandsMask operator&(ImageOperandsMask a, ImageOperandsMask b) { return ImageOperandsMask(unsigned(a) & unsigned(b)); }
inline ImageOperandsMask operator^(ImageOperandsMask a, ImageOperandsMask b) { return ImageOperandsMask(unsigned(a) ^ unsigned(b)); }
inline MemoryAccessMask operator&(MemoryAccessMask a, MemoryAccessMask b) { return MemoryAccessMask(unsigned(a) & unsigned(b)); }
inline MemoryAccessMask operator^(MemoryAccessMask a, MemoryAccessMask b) { return MemoryAccessMask(unsigned(a) ^ unsigned(b)); }
inline FPFastMathModeMask operator&(FPFastMathModeMask a, FPFastMathModeMask b)
{
  return FPFastMathModeMask(unsigned(a) & unsigned(b));
}
inline FPFastMathModeMask operator^(FPFastMathModeMask a, FPFastMathModeMask b)
{
  return FPFastMathModeMask(unsigned(a) ^ unsigned(b));
}
inline KernelProfilingInfoMask operator&(KernelProfilingInfoMask a, KernelProfilingInfoMask b)
{
  return KernelProfilingInfoMask(unsigned(a) & unsigned(b));
}
inline KernelProfilingInfoMask operator^(KernelProfilingInfoMask a, KernelProfilingInfoMask b)
{
  return KernelProfilingInfoMask(unsigned(a) ^ unsigned(b));
}
// type traits
template <>
struct TypeTraits<LiteralSpecConstantOpInteger>
{
  static const char *doc()
  {
    return "An opcode indicating the operation to be performed and determining the layout of following operands (for "
           "OpSpecConstantOp)";
  }
  static const char *name() { return "LiteralSpecConstantOpInteger"; }
  typedef LiteralSpecConstantOpInteger ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{*from++};
    return result;
  };
};
template <>
struct TypeTraits<LiteralExtInstInteger>
{
  static const char *doc()
  {
    return "A 32-bit unsigned integer indicating which instruction to use and determining the layout of following operands (for "
           "OpExtInst)";
  }
  static const char *name() { return "LiteralExtInstInteger"; }
  typedef LiteralExtInstInteger ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{*from++};
    return result;
  };
};
struct IdRefTag;
typedef detail::TaggedType<Id, IdRefTag> IdRef;
template <>
struct TypeTraits<IdRef> : detail::BasicIdTypeTraits<IdRef>
{
  static const char *doc() { return "Reference to an <id>"; }
  static const char *name() { return "IdRef"; }
};
struct IdResultTypeTag;
typedef detail::TaggedType<Id, IdResultTypeTag> IdResultType;
template <>
struct TypeTraits<IdResultType> : detail::BasicIdTypeTraits<IdResultType>
{
  static const char *doc() { return "Reference to an <id> representing the result's type of the enclosing instruction"; }
  static const char *name() { return "IdResultType"; }
};
struct IdScopeTag;
typedef detail::TaggedType<Id, IdScopeTag> IdScope;
template <>
struct TypeTraits<IdScope> : detail::BasicIdTypeTraits<IdScope>
{
  static const char *doc() { return "Reference to an <id> representing a 32-bit integer that is a mask from the Scope operand kind"; }
  static const char *name() { return "IdScope"; }
};
struct IdResultTag;
typedef detail::TaggedType<Id, IdResultTag> IdResult;
template <>
struct TypeTraits<IdResult> : detail::BasicIdTypeTraits<IdResult>
{
  static const char *doc() { return "Definition of an <id> representing the result of the enclosing instruction"; }
  static const char *name() { return "IdResult"; }
};
template <>
struct TypeTraits<LiteralString>
{
  static const char *doc() { return "A null-terminated stream of characters consuming an integral number of words"; }
  static const char *name() { return "LiteralString"; }
  typedef LiteralString ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<Id>(to - from), from};
    from += result.words();
    return result;
  };
};
struct IdMemorySemanticsTag;
typedef detail::TaggedType<Id, IdMemorySemanticsTag> IdMemorySemantics;
template <>
struct TypeTraits<IdMemorySemantics> : detail::BasicIdTypeTraits<IdMemorySemantics>
{
  static const char *doc()
  {
    return "Reference to an <id> representing a 32-bit integer that is a mask from the MemorySemantics operand kind";
  }
  static const char *name() { return "IdMemorySemantics"; }
};
template <>
struct TypeTraits<LiteralContextDependentNumber>
{
  static const char *doc()
  {
    return "A literal number whose size and format are determined by a previous operand in the enclosing instruction";
  }
  static const char *name() { return "LiteralContextDependentNumber"; }
  typedef LiteralContextDependentNumber ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < (cds / (8 * sizeof(Id))))
    {
      error = true;
      return {};
    }
    unsigned long long v = *from++;
    if (cds > 32)
    {
      v |= (unsigned long long)(*from) << 32;
      from++;
    }
    return {v};
  };
};
template <>
struct TypeTraits<LiteralInteger>
{
  static const char *doc() { return "An integer consuming one or more words"; }
  static const char *name() { return "LiteralInteger"; }
  typedef LiteralInteger ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{*from++};
    return result;
  };
};
// reordered type traits defenitions
//  BuiltIn
//  FunctionParameterAttribute
//  FPRoundingMode
//  FPFastMathMode
//  LinkageType
//  FPDenormMode
//  FPOperationMode
template <>
struct TypeTraits<BuiltIn>
{
  static const char *doc() { return ""; }
  static const char *name() { return "BuiltIn"; }
  typedef BuiltIn ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<FunctionParameterAttribute>
{
  static const char *doc() { return ""; }
  static const char *name() { return "FunctionParameterAttribute"; }
  typedef FunctionParameterAttribute ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<FPRoundingMode>
{
  static const char *doc() { return ""; }
  static const char *name() { return "FPRoundingMode"; }
  typedef FPRoundingMode ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<FPFastMathModeMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "FPFastMathMode"; }
  typedef FPFastMathModeMask ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  };
};
template <>
struct TypeTraits<LinkageType>
{
  static const char *doc() { return ""; }
  static const char *name() { return "LinkageType"; }
  typedef LinkageType ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<FPDenormMode>
{
  static const char *doc() { return ""; }
  static const char *name() { return "FPDenormMode"; }
  typedef FPDenormMode ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<FPOperationMode>
{
  static const char *doc() { return ""; }
  static const char *name() { return "FPOperationMode"; }
  typedef FPOperationMode ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<SamplerFilterMode>
{
  static const char *doc() { return ""; }
  static const char *name() { return "SamplerFilterMode"; }
  typedef SamplerFilterMode ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<ImageChannelOrder>
{
  static const char *doc() { return ""; }
  static const char *name() { return "ImageChannelOrder"; }
  typedef ImageChannelOrder ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<KernelEnqueueFlags>
{
  static const char *doc() { return ""; }
  static const char *name() { return "KernelEnqueueFlags"; }
  typedef KernelEnqueueFlags ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<MemorySemanticsMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "MemorySemantics"; }
  typedef MemorySemanticsMask ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  };
};
template <>
struct TypeTraits<SelectionControlMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "SelectionControl"; }
  typedef SelectionControlMask ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  };
};
template <>
struct TypeTraits<RayQueryIntersection>
{
  static const char *doc() { return ""; }
  static const char *name() { return "RayQueryIntersection"; }
  typedef RayQueryIntersection ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<ImageFormat>
{
  static const char *doc() { return ""; }
  static const char *name() { return "ImageFormat"; }
  typedef ImageFormat ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<Scope>
{
  static const char *doc() { return ""; }
  static const char *name() { return "Scope"; }
  typedef Scope ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<LoopControlMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "LoopControl"; }
  struct ReadType
  {
    LoopControlMask value;
    struct DataTag
    {
      struct DependencyLengthTag
      {
        LiteralInteger first;
      } DependencyLength;
      struct MinIterationsTag
      {
        LiteralInteger first;
      } MinIterations;
      struct MaxIterationsTag
      {
        LiteralInteger first;
      } MaxIterations;
      struct IterationMultipleTag
      {
        LiteralInteger first;
      } IterationMultiple;
      struct PeelCountTag
      {
        LiteralInteger first;
      } PeelCount;
      struct PartialCountTag
      {
        LiteralInteger first;
      } PartialCount;
      struct InitiationIntervalINTELTag
      {
        LiteralInteger first;
      } InitiationIntervalINTEL;
      struct MaxConcurrencyINTELTag
      {
        LiteralInteger first;
      } MaxConcurrencyINTEL;
      struct DependencyArrayINTELTag
      {
        LiteralInteger first;
      } DependencyArrayINTEL;
      struct PipelineEnableINTELTag
      {
        LiteralInteger first;
      } PipelineEnableINTEL;
      struct LoopCoalesceINTELTag
      {
        LiteralInteger first;
      } LoopCoalesceINTEL;
      struct MaxInterleavingINTELTag
      {
        LiteralInteger first;
      } MaxInterleavingINTEL;
      struct SpeculatedIterationsINTELTag
      {
        LiteralInteger first;
      } SpeculatedIterationsINTEL;
      struct NoFusionINTELTag
      {
        LiteralInteger first;
      } NoFusionINTEL;
    } data;
  };
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result;
    result.value = static_cast<LoopControlMask>(*from++);
    if (LoopControlMask::DependencyLength == (result.value & LoopControlMask::DependencyLength))
    {
      result.data.DependencyLength.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::MinIterations == (result.value & LoopControlMask::MinIterations))
    {
      result.data.MinIterations.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::MaxIterations == (result.value & LoopControlMask::MaxIterations))
    {
      result.data.MaxIterations.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::IterationMultiple == (result.value & LoopControlMask::IterationMultiple))
    {
      result.data.IterationMultiple.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::PeelCount == (result.value & LoopControlMask::PeelCount))
    {
      result.data.PeelCount.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::PartialCount == (result.value & LoopControlMask::PartialCount))
    {
      result.data.PartialCount.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::InitiationIntervalINTEL == (result.value & LoopControlMask::InitiationIntervalINTEL))
    {
      result.data.InitiationIntervalINTEL.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::MaxConcurrencyINTEL == (result.value & LoopControlMask::MaxConcurrencyINTEL))
    {
      result.data.MaxConcurrencyINTEL.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::DependencyArrayINTEL == (result.value & LoopControlMask::DependencyArrayINTEL))
    {
      result.data.DependencyArrayINTEL.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::PipelineEnableINTEL == (result.value & LoopControlMask::PipelineEnableINTEL))
    {
      result.data.PipelineEnableINTEL.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::LoopCoalesceINTEL == (result.value & LoopControlMask::LoopCoalesceINTEL))
    {
      result.data.LoopCoalesceINTEL.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::MaxInterleavingINTEL == (result.value & LoopControlMask::MaxInterleavingINTEL))
    {
      result.data.MaxInterleavingINTEL.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::SpeculatedIterationsINTEL == (result.value & LoopControlMask::SpeculatedIterationsINTEL))
    {
      result.data.SpeculatedIterationsINTEL.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    if (LoopControlMask::NoFusionINTEL == (result.value & LoopControlMask::NoFusionINTEL))
    {
      result.data.NoFusionINTEL.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
    }
    return result;
  };
};
template <>
struct TypeTraits<ImageChannelDataType>
{
  static const char *doc() { return ""; }
  static const char *name() { return "ImageChannelDataType"; }
  typedef ImageChannelDataType ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<Decoration>
{
  static const char *doc() { return ""; }
  static const char *name() { return "Decoration"; }
  struct ReadType
  {
    Decoration value;
    union DataTag
    {
      struct SpecIdTag
      {
        LiteralInteger specializationConstantId;
      } SpecId;
      struct ArrayStrideTag
      {
        LiteralInteger arrayStride;
      } ArrayStride;
      struct MatrixStrideTag
      {
        LiteralInteger matrixStride;
      } MatrixStride;
      struct BuiltInTag
      {
        BuiltIn first;
      } BuiltInData;
      struct UniformIdTag
      {
        IdScope execution;
      } UniformId;
      struct StreamTag
      {
        LiteralInteger streamNumber;
      } Stream;
      struct LocationTag
      {
        LiteralInteger location;
      } Location;
      struct ComponentTag
      {
        LiteralInteger component;
      } Component;
      struct IndexTag
      {
        LiteralInteger index;
      } Index;
      struct BindingTag
      {
        LiteralInteger bindingPoint;
      } Binding;
      struct DescriptorSetTag
      {
        LiteralInteger descriptorSet;
      } DescriptorSet;
      struct OffsetTag
      {
        LiteralInteger byteOffset;
      } Offset;
      struct XfbBufferTag
      {
        LiteralInteger xfbBufferNumber;
      } XfbBuffer;
      struct XfbStrideTag
      {
        LiteralInteger xfbStride;
      } XfbStride;
      struct FuncParamAttrTag
      {
        FunctionParameterAttribute functionParameterAttribute;
      } FuncParamAttr;
      struct FPRoundingModeTag
      {
        FPRoundingModeValue floatingPointRoundingMode;
      } FPRoundingMode;
      struct FPFastMathModeTag
      {
        FPFastMathModeMask fastMathMode;
      } FPFastMathMode;
      struct LinkageAttributesTag
      {
        LiteralString name;
        LinkageType linkageType;
      } LinkageAttributes;
      struct InputAttachmentIndexTag
      {
        LiteralInteger attachmentIndex;
      } InputAttachmentIndex;
      struct AlignmentTag
      {
        LiteralInteger alignment;
      } Alignment;
      struct MaxByteOffsetTag
      {
        LiteralInteger maxByteOffset;
      } MaxByteOffset;
      struct AlignmentIdTag
      {
        IdRef alignment;
      } AlignmentId;
      struct MaxByteOffsetIdTag
      {
        IdRef maxByteOffset;
      } MaxByteOffsetId;
      struct SecondaryViewportRelativeNVTag
      {
        LiteralInteger offset;
      } SecondaryViewportRelativeNV;
      struct SIMTCallINTELTag
      {
        LiteralInteger n;
      } SIMTCallINTEL;
      struct ClobberINTELTag
      {
        LiteralString _register;
      } ClobberINTEL;
      struct FuncParamIOKindINTELTag
      {
        LiteralInteger kind;
      } FuncParamIOKindINTEL;
      struct GlobalVariableOffsetINTELTag
      {
        LiteralInteger offset;
      } GlobalVariableOffsetINTEL;
      struct CounterBufferTag
      {
        IdRef counterBuffer;
      } CounterBuffer;
      struct HlslCounterBufferGOOGLETag
      {
        IdRef counterBuffer;
      } HlslCounterBufferGOOGLE;
      struct UserSemanticTag
      {
        LiteralString semantic;
      } UserSemantic;
      struct HlslSemanticGOOGLETag
      {
        LiteralString semantic;
      } HlslSemanticGOOGLE;
      struct UserTypeGOOGLETag
      {
        LiteralString userType;
      } UserTypeGOOGLE;
      struct FunctionRoundingModeINTELTag
      {
        LiteralInteger targetWidth;
        FPRoundingModeValue fpRoundingMode;
      } FunctionRoundingModeINTEL;
      struct FunctionDenormModeINTELTag
      {
        LiteralInteger targetWidth;
        FPDenormMode fpDenormMode;
      } FunctionDenormModeINTEL;
      struct MemoryINTELTag
      {
        LiteralString memoryType;
      } MemoryINTEL;
      struct NumbanksINTELTag
      {
        LiteralInteger banks;
      } NumbanksINTEL;
      struct BankwidthINTELTag
      {
        LiteralInteger bankWidth;
      } BankwidthINTEL;
      struct MaxPrivateCopiesINTELTag
      {
        LiteralInteger maximumCopies;
      } MaxPrivateCopiesINTEL;
      struct MaxReplicatesINTELTag
      {
        LiteralInteger maximumReplicates;
      } MaxReplicatesINTEL;
      struct MergeINTELTag
      {
        LiteralString mergeKey;
        LiteralString mergeType;
      } MergeINTEL;
      struct BankBitsINTELTag
      {
        LiteralInteger bankBits;
      } BankBitsINTEL;
      struct ForcePow2DepthINTELTag
      {
        LiteralInteger forceKey;
      } ForcePow2DepthINTEL;
      struct CacheSizeINTELTag
      {
        LiteralInteger cacheSizeInBytes;
      } CacheSizeINTEL;
      struct PrefetchINTELTag
      {
        LiteralInteger prefetcherSizeInBytes;
      } PrefetchINTEL;
      struct BufferLocationINTELTag
      {
        LiteralInteger bufferLocationId;
      } BufferLocationINTEL;
      struct IOPipeStorageINTELTag
      {
        LiteralInteger ioPipeId;
      } IOPipeStorageINTEL;
      struct FunctionFloatingPointModeINTELTag
      {
        LiteralInteger targetWidth;
        FPOperationMode fpOperationMode;
      } FunctionFloatingPointModeINTEL;
    } data;
  };
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result;
    result.value = static_cast<Decoration>(*from++);
    switch (result.value)
    {
      default: error = true; return {};
      case Decoration::RelaxedPrecision:
      case Decoration::Block:
      case Decoration::BufferBlock:
      case Decoration::RowMajor:
      case Decoration::ColMajor:
      case Decoration::GLSLShared:
      case Decoration::GLSLPacked:
      case Decoration::CPacked:
      case Decoration::NoPerspective:
      case Decoration::Flat:
      case Decoration::Patch:
      case Decoration::Centroid:
      case Decoration::Sample:
      case Decoration::Invariant:
      case Decoration::Restrict:
      case Decoration::Aliased:
      case Decoration::Volatile:
      case Decoration::Constant:
      case Decoration::Coherent:
      case Decoration::NonWritable:
      case Decoration::NonReadable:
      case Decoration::Uniform:
      case Decoration::SaturatedConversion:
      case Decoration::NoContraction:
      case Decoration::NoSignedWrap:
      case Decoration::NoUnsignedWrap:
      case Decoration::ExplicitInterpAMD:
      case Decoration::OverrideCoverageNV:
      case Decoration::PassthroughNV:
      case Decoration::ViewportRelativeNV:
      case Decoration::PerPrimitiveNV:
      case Decoration::PerViewNV:
      case Decoration::PerTaskNV:
      case Decoration::PerVertexKHR:
      case Decoration::NonUniform:
      case Decoration::RestrictPointer:
      case Decoration::AliasedPointer:
      case Decoration::BindlessSamplerNV:
      case Decoration::BindlessImageNV:
      case Decoration::BoundSamplerNV:
      case Decoration::BoundImageNV:
      case Decoration::ReferencedIndirectlyINTEL:
      case Decoration::SideEffectsINTEL:
      case Decoration::VectorComputeVariableINTEL:
      case Decoration::VectorComputeFunctionINTEL:
      case Decoration::StackCallINTEL:
      case Decoration::RegisterINTEL:
      case Decoration::SinglepumpINTEL:
      case Decoration::DoublepumpINTEL:
      case Decoration::SimpleDualPortINTEL:
      case Decoration::BurstCoalesceINTEL:
      case Decoration::DontStaticallyCoalesceINTEL:
      case Decoration::StallEnableINTEL:
      case Decoration::FuseLoopsInFunctionINTEL:
      case Decoration::SingleElementVectorINTEL:
      case Decoration::VectorComputeCallableFunctionINTEL:
      case Decoration::MediaBlockIOINTEL: break;
      case Decoration::SpecId:
      {
        result.data.SpecId.specializationConstantId = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::ArrayStride:
      {
        result.data.ArrayStride.arrayStride = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::MatrixStride:
      {
        result.data.MatrixStride.matrixStride = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::BuiltIn:
      {
        result.data.BuiltInData.first = TypeTraits<BuiltIn>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::UniformId:
      {
        result.data.UniformId.execution = TypeTraits<IdScope>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::Stream:
      {
        result.data.Stream.streamNumber = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::Location:
      {
        result.data.Location.location = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::Component:
      {
        result.data.Component.component = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::Index:
      {
        result.data.Index.index = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::Binding:
      {
        result.data.Binding.bindingPoint = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::DescriptorSet:
      {
        result.data.DescriptorSet.descriptorSet = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::Offset:
      {
        result.data.Offset.byteOffset = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::XfbBuffer:
      {
        result.data.XfbBuffer.xfbBufferNumber = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::XfbStride:
      {
        result.data.XfbStride.xfbStride = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::FuncParamAttr:
      {
        result.data.FuncParamAttr.functionParameterAttribute = TypeTraits<FunctionParameterAttribute>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::FPRoundingMode:
      {
        result.data.FPRoundingMode.floatingPointRoundingMode = TypeTraits<FPRoundingModeValue>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::FPFastMathMode:
      {
        result.data.FPFastMathMode.fastMathMode = TypeTraits<FPFastMathModeMask>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::LinkageAttributes:
      {
        result.data.LinkageAttributes.name = TypeTraits<LiteralString>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LinkageAttributes.linkageType = TypeTraits<LinkageType>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::InputAttachmentIndex:
      {
        result.data.InputAttachmentIndex.attachmentIndex = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::Alignment:
      {
        result.data.Alignment.alignment = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::MaxByteOffset:
      {
        result.data.MaxByteOffset.maxByteOffset = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::AlignmentId:
      {
        result.data.AlignmentId.alignment = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::MaxByteOffsetId:
      {
        result.data.MaxByteOffsetId.maxByteOffset = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::SecondaryViewportRelativeNV:
      {
        result.data.SecondaryViewportRelativeNV.offset = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::SIMTCallINTEL:
      {
        result.data.SIMTCallINTEL.n = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::ClobberINTEL:
      {
        result.data.ClobberINTEL._register = TypeTraits<LiteralString>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::FuncParamIOKindINTEL:
      {
        result.data.FuncParamIOKindINTEL.kind = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::GlobalVariableOffsetINTEL:
      {
        result.data.GlobalVariableOffsetINTEL.offset = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::CounterBuffer:
      {
        result.data.CounterBuffer.counterBuffer = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::UserSemantic:
      {
        result.data.UserSemantic.semantic = TypeTraits<LiteralString>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::UserTypeGOOGLE:
      {
        result.data.UserTypeGOOGLE.userType = TypeTraits<LiteralString>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::FunctionRoundingModeINTEL:
      {
        result.data.FunctionRoundingModeINTEL.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.FunctionRoundingModeINTEL.fpRoundingMode = TypeTraits<FPRoundingModeValue>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::FunctionDenormModeINTEL:
      {
        result.data.FunctionDenormModeINTEL.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.FunctionDenormModeINTEL.fpDenormMode = TypeTraits<FPDenormMode>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::MemoryINTEL:
      {
        result.data.MemoryINTEL.memoryType = TypeTraits<LiteralString>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::NumbanksINTEL:
      {
        result.data.NumbanksINTEL.banks = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::BankwidthINTEL:
      {
        result.data.BankwidthINTEL.bankWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::MaxPrivateCopiesINTEL:
      {
        result.data.MaxPrivateCopiesINTEL.maximumCopies = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::MaxReplicatesINTEL:
      {
        result.data.MaxReplicatesINTEL.maximumReplicates = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::MergeINTEL:
      {
        result.data.MergeINTEL.mergeKey = TypeTraits<LiteralString>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.MergeINTEL.mergeType = TypeTraits<LiteralString>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::BankBitsINTEL:
      {
        result.data.BankBitsINTEL.bankBits = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::ForcePow2DepthINTEL:
      {
        result.data.ForcePow2DepthINTEL.forceKey = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::CacheSizeINTEL:
      {
        result.data.CacheSizeINTEL.cacheSizeInBytes = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::PrefetchINTEL:
      {
        result.data.PrefetchINTEL.prefetcherSizeInBytes = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::BufferLocationINTEL:
      {
        result.data.BufferLocationINTEL.bufferLocationId = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::IOPipeStorageINTEL:
      {
        result.data.IOPipeStorageINTEL.ioPipeId = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case Decoration::FunctionFloatingPointModeINTEL:
      {
        result.data.FunctionFloatingPointModeINTEL.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.FunctionFloatingPointModeINTEL.fpOperationMode = TypeTraits<FPOperationMode>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
    };
    return result;
  }
};
template <>
struct TypeTraits<QuantizationModes>
{
  static const char *doc() { return ""; }
  static const char *name() { return "QuantizationModes"; }
  typedef QuantizationModes ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<RayFlagsMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "RayFlags"; }
  typedef RayFlagsMask ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  };
};
template <>
struct TypeTraits<FragmentShadingRateMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "FragmentShadingRate"; }
  typedef FragmentShadingRateMask ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  };
};
template <>
struct TypeTraits<FunctionControlMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "FunctionControl"; }
  typedef FunctionControlMask ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  };
};
template <>
struct TypeTraits<AddressingModel>
{
  static const char *doc() { return ""; }
  static const char *name() { return "AddressingModel"; }
  typedef AddressingModel ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<PackedVectorFormat>
{
  static const char *doc() { return ""; }
  static const char *name() { return "PackedVectorFormat"; }
  typedef PackedVectorFormat ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<Dim>
{
  static const char *doc() { return ""; }
  static const char *name() { return "Dim"; }
  typedef Dim ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<OverflowModes>
{
  static const char *doc() { return ""; }
  static const char *name() { return "OverflowModes"; }
  typedef OverflowModes ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<ImageOperandsMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "ImageOperands"; }
  struct ReadType
  {
    ImageOperandsMask value;
    struct DataTag
    {
      struct BiasTag
      {
        IdRef first;
      } Bias;
      struct LodTag
      {
        IdRef first;
      } Lod;
      struct GradTag
      {
        IdRef first;
        IdRef second;
      } Grad;
      struct ConstOffsetTag
      {
        IdRef first;
      } ConstOffset;
      struct OffsetTag
      {
        IdRef first;
      } Offset;
      struct ConstOffsetsTag
      {
        IdRef first;
      } ConstOffsets;
      struct SampleTag
      {
        IdRef first;
      } Sample;
      struct MinLodTag
      {
        IdRef first;
      } MinLod;
      struct MakeTexelAvailableTag
      {
        IdScope first;
      } MakeTexelAvailable;
      struct MakeTexelAvailableKHRTag
      {
        IdScope first;
      } MakeTexelAvailableKHR;
      struct MakeTexelVisibleTag
      {
        IdScope first;
      } MakeTexelVisible;
      struct MakeTexelVisibleKHRTag
      {
        IdScope first;
      } MakeTexelVisibleKHR;
      struct OffsetsTag
      {
        IdRef first;
      } Offsets;
    } data;
  };
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result;
    result.value = static_cast<ImageOperandsMask>(*from++);
    auto compareValue = result.value;
    if (ImageOperandsMask::Bias == (compareValue & ImageOperandsMask::Bias))
    {
      result.data.Bias.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::Bias;
    }
    if (ImageOperandsMask::Lod == (compareValue & ImageOperandsMask::Lod))
    {
      result.data.Lod.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::Lod;
    }
    if (ImageOperandsMask::Grad == (compareValue & ImageOperandsMask::Grad))
    {
      result.data.Grad.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      result.data.Grad.second = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::Grad;
    }
    if (ImageOperandsMask::ConstOffset == (compareValue & ImageOperandsMask::ConstOffset))
    {
      result.data.ConstOffset.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::ConstOffset;
    }
    if (ImageOperandsMask::Offset == (compareValue & ImageOperandsMask::Offset))
    {
      result.data.Offset.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::Offset;
    }
    if (ImageOperandsMask::ConstOffsets == (compareValue & ImageOperandsMask::ConstOffsets))
    {
      result.data.ConstOffsets.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::ConstOffsets;
    }
    if (ImageOperandsMask::Sample == (compareValue & ImageOperandsMask::Sample))
    {
      result.data.Sample.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::Sample;
    }
    if (ImageOperandsMask::MinLod == (compareValue & ImageOperandsMask::MinLod))
    {
      result.data.MinLod.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::MinLod;
    }
    if (ImageOperandsMask::MakeTexelAvailable == (compareValue & ImageOperandsMask::MakeTexelAvailable))
    {
      result.data.MakeTexelAvailable.first = TypeTraits<IdScope>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::MakeTexelAvailable;
    }
    if (ImageOperandsMask::MakeTexelVisible == (compareValue & ImageOperandsMask::MakeTexelVisible))
    {
      result.data.MakeTexelVisible.first = TypeTraits<IdScope>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::MakeTexelVisible;
    }
    if (ImageOperandsMask::NonPrivateTexel == (compareValue & ImageOperandsMask::NonPrivateTexel))
    {
      compareValue = compareValue ^ ImageOperandsMask::NonPrivateTexel;
    }
    if (ImageOperandsMask::VolatileTexel == (compareValue & ImageOperandsMask::VolatileTexel))
    {
      compareValue = compareValue ^ ImageOperandsMask::VolatileTexel;
    }
    if (ImageOperandsMask::SignExtend == (compareValue & ImageOperandsMask::SignExtend))
    {
      compareValue = compareValue ^ ImageOperandsMask::SignExtend;
    }
    if (ImageOperandsMask::ZeroExtend == (compareValue & ImageOperandsMask::ZeroExtend))
    {
      compareValue = compareValue ^ ImageOperandsMask::ZeroExtend;
    }
    if (ImageOperandsMask::Nontemporal == (compareValue & ImageOperandsMask::Nontemporal))
    {
      compareValue = compareValue ^ ImageOperandsMask::Nontemporal;
    }
    if (ImageOperandsMask::Offsets == (compareValue & ImageOperandsMask::Offsets))
    {
      result.data.Offsets.first = TypeTraits<IdRef>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ ImageOperandsMask::Offsets;
    }
    return result;
  };
};
template <>
struct TypeTraits<Capability>
{
  static const char *doc() { return ""; }
  static const char *name() { return "Capability"; }
  typedef Capability ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<MemoryAccessMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "MemoryAccess"; }
  struct ReadType
  {
    MemoryAccessMask value;
    struct DataTag
    {
      struct AlignedTag
      {
        LiteralInteger first;
      } Aligned;
      struct MakePointerAvailableTag
      {
        IdScope first;
      } MakePointerAvailable;
      struct MakePointerAvailableKHRTag
      {
        IdScope first;
      } MakePointerAvailableKHR;
      struct MakePointerVisibleTag
      {
        IdScope first;
      } MakePointerVisible;
      struct MakePointerVisibleKHRTag
      {
        IdScope first;
      } MakePointerVisibleKHR;
    } data;
  };
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result;
    result.value = static_cast<MemoryAccessMask>(*from++);
    auto compareValue = result.value;
    if (MemoryAccessMask::Volatile == (compareValue & MemoryAccessMask::Volatile))
    {
      compareValue = compareValue ^ MemoryAccessMask::Volatile;
    }
    if (MemoryAccessMask::Aligned == (compareValue & MemoryAccessMask::Aligned))
    {
      result.data.Aligned.first = TypeTraits<LiteralInteger>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ MemoryAccessMask::Aligned;
    }
    if (MemoryAccessMask::Nontemporal == (compareValue & MemoryAccessMask::Nontemporal))
    {
      compareValue = compareValue ^ MemoryAccessMask::Nontemporal;
    }
    if (MemoryAccessMask::MakePointerAvailable == (compareValue & MemoryAccessMask::MakePointerAvailable))
    {
      result.data.MakePointerAvailable.first = TypeTraits<IdScope>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ MemoryAccessMask::MakePointerAvailable;
    }
    if (MemoryAccessMask::MakePointerVisible == (compareValue & MemoryAccessMask::MakePointerVisible))
    {
      result.data.MakePointerVisible.first = TypeTraits<IdScope>::read(from, to, cds, error);
      if (error)
        return {};
      compareValue = compareValue ^ MemoryAccessMask::MakePointerVisible;
    }
    if (MemoryAccessMask::NonPrivatePointer == (compareValue & MemoryAccessMask::NonPrivatePointer))
    {
      compareValue = compareValue ^ MemoryAccessMask::NonPrivatePointer;
    }
    return result;
  };
};
template <>
struct TypeTraits<GroupOperation>
{
  static const char *doc() { return ""; }
  static const char *name() { return "GroupOperation"; }
  typedef GroupOperation ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<ExecutionModel>
{
  static const char *doc() { return ""; }
  static const char *name() { return "ExecutionModel"; }
  typedef ExecutionModel ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<AccessQualifier>
{
  static const char *doc() { return ""; }
  static const char *name() { return "AccessQualifier"; }
  typedef AccessQualifier ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<RayQueryCommittedIntersectionType>
{
  static const char *doc() { return ""; }
  static const char *name() { return "RayQueryCommittedIntersectionType"; }
  typedef RayQueryCommittedIntersectionType ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<SourceLanguage>
{
  static const char *doc() { return ""; }
  static const char *name() { return "SourceLanguage"; }
  typedef SourceLanguage ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<KernelProfilingInfoMask>
{
  static const char *doc() { return ""; }
  static const char *name() { return "KernelProfilingInfo"; }
  typedef KernelProfilingInfoMask ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  };
};
template <>
struct TypeTraits<ExecutionMode>
{
  static const char *doc() { return ""; }
  static const char *name() { return "ExecutionMode"; }
  struct ReadType
  {
    ExecutionMode value;
    union DataTag
    {
      struct InvocationsTag
      {
        LiteralInteger numberOfInvocationInvocations;
      } Invocations;
      struct LocalSizeTag
      {
        LiteralInteger xSize;
        LiteralInteger ySize;
        LiteralInteger zSize;
      } LocalSize;
      struct LocalSizeHintTag
      {
        LiteralInteger xSize;
        LiteralInteger ySize;
        LiteralInteger zSize;
      } LocalSizeHint;
      struct OutputVerticesTag
      {
        LiteralInteger vertexCount;
      } OutputVertices;
      struct VecTypeHintTag
      {
        LiteralInteger vectorType;
      } VecTypeHint;
      struct SubgroupSizeTag
      {
        LiteralInteger subgroupSize;
      } SubgroupSize;
      struct SubgroupsPerWorkgroupTag
      {
        LiteralInteger subgroupsPerWorkgroup;
      } SubgroupsPerWorkgroup;
      struct SubgroupsPerWorkgroupIdTag
      {
        IdRef subgroupsPerWorkgroup;
      } SubgroupsPerWorkgroupId;
      struct LocalSizeIdTag
      {
        IdRef xSize;
        IdRef ySize;
        IdRef zSize;
      } LocalSizeId;
      struct LocalSizeHintIdTag
      {
        IdRef xSizeHint;
        IdRef ySizeHint;
        IdRef zSizeHint;
      } LocalSizeHintId;
      struct DenormPreserveTag
      {
        LiteralInteger targetWidth;
      } DenormPreserve;
      struct DenormFlushToZeroTag
      {
        LiteralInteger targetWidth;
      } DenormFlushToZero;
      struct SignedZeroInfNanPreserveTag
      {
        LiteralInteger targetWidth;
      } SignedZeroInfNanPreserve;
      struct RoundingModeRTETag
      {
        LiteralInteger targetWidth;
      } RoundingModeRTE;
      struct RoundingModeRTZTag
      {
        LiteralInteger targetWidth;
      } RoundingModeRTZ;
      struct OutputPrimitivesNVTag
      {
        LiteralInteger primitiveCount;
      } OutputPrimitivesNV;
      struct SharedLocalMemorySizeINTELTag
      {
        LiteralInteger size;
      } SharedLocalMemorySizeINTEL;
      struct RoundingModeRTPINTELTag
      {
        LiteralInteger targetWidth;
      } RoundingModeRTPINTEL;
      struct RoundingModeRTNINTELTag
      {
        LiteralInteger targetWidth;
      } RoundingModeRTNINTEL;
      struct FloatingPointModeALTINTELTag
      {
        LiteralInteger targetWidth;
      } FloatingPointModeALTINTEL;
      struct FloatingPointModeIEEEINTELTag
      {
        LiteralInteger targetWidth;
      } FloatingPointModeIEEEINTEL;
      struct MaxWorkgroupSizeINTELTag
      {
        LiteralInteger max_x_size;
        LiteralInteger max_y_size;
        LiteralInteger max_z_size;
      } MaxWorkgroupSizeINTEL;
      struct MaxWorkDimINTELTag
      {
        LiteralInteger max_dimensions;
      } MaxWorkDimINTEL;
      struct NumSIMDWorkitemsINTELTag
      {
        LiteralInteger vector_width;
      } NumSIMDWorkitemsINTEL;
      struct SchedulerTargetFmaxMhzINTELTag
      {
        LiteralInteger target_fmax;
      } SchedulerTargetFmaxMhzINTEL;
    } data;
  };
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result;
    result.value = static_cast<ExecutionMode>(*from++);
    switch (result.value)
    {
      default: error = true; return {};
      case ExecutionMode::SpacingEqual:
      case ExecutionMode::SpacingFractionalEven:
      case ExecutionMode::SpacingFractionalOdd:
      case ExecutionMode::VertexOrderCw:
      case ExecutionMode::VertexOrderCcw:
      case ExecutionMode::PixelCenterInteger:
      case ExecutionMode::OriginUpperLeft:
      case ExecutionMode::OriginLowerLeft:
      case ExecutionMode::EarlyFragmentTests:
      case ExecutionMode::PointMode:
      case ExecutionMode::Xfb:
      case ExecutionMode::DepthReplacing:
      case ExecutionMode::DepthGreater:
      case ExecutionMode::DepthLess:
      case ExecutionMode::DepthUnchanged:
      case ExecutionMode::InputPoints:
      case ExecutionMode::InputLines:
      case ExecutionMode::InputLinesAdjacency:
      case ExecutionMode::Triangles:
      case ExecutionMode::InputTrianglesAdjacency:
      case ExecutionMode::Quads:
      case ExecutionMode::Isolines:
      case ExecutionMode::OutputPoints:
      case ExecutionMode::OutputLineStrip:
      case ExecutionMode::OutputTriangleStrip:
      case ExecutionMode::ContractionOff:
      case ExecutionMode::Initializer:
      case ExecutionMode::Finalizer:
      case ExecutionMode::SubgroupUniformControlFlowKHR:
      case ExecutionMode::PostDepthCoverage:
      case ExecutionMode::StencilRefReplacingEXT:
      case ExecutionMode::OutputLinesNV:
      case ExecutionMode::DerivativeGroupQuadsNV:
      case ExecutionMode::DerivativeGroupLinearNV:
      case ExecutionMode::OutputTrianglesNV:
      case ExecutionMode::PixelInterlockOrderedEXT:
      case ExecutionMode::PixelInterlockUnorderedEXT:
      case ExecutionMode::SampleInterlockOrderedEXT:
      case ExecutionMode::SampleInterlockUnorderedEXT:
      case ExecutionMode::ShadingRateInterlockOrderedEXT:
      case ExecutionMode::ShadingRateInterlockUnorderedEXT:
      case ExecutionMode::NoGlobalOffsetINTEL: break;
      case ExecutionMode::Invocations:
      {
        result.data.Invocations.numberOfInvocationInvocations = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::LocalSize:
      {
        result.data.LocalSize.xSize = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LocalSize.ySize = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LocalSize.zSize = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::LocalSizeHint:
      {
        result.data.LocalSizeHint.xSize = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LocalSizeHint.ySize = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LocalSizeHint.zSize = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::OutputVertices:
      {
        result.data.OutputVertices.vertexCount = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::VecTypeHint:
      {
        result.data.VecTypeHint.vectorType = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::SubgroupSize:
      {
        result.data.SubgroupSize.subgroupSize = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::SubgroupsPerWorkgroup:
      {
        result.data.SubgroupsPerWorkgroup.subgroupsPerWorkgroup = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::SubgroupsPerWorkgroupId:
      {
        result.data.SubgroupsPerWorkgroupId.subgroupsPerWorkgroup = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::LocalSizeId:
      {
        result.data.LocalSizeId.xSize = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LocalSizeId.ySize = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LocalSizeId.zSize = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::LocalSizeHintId:
      {
        result.data.LocalSizeHintId.xSizeHint = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LocalSizeHintId.ySizeHint = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.LocalSizeHintId.zSizeHint = TypeTraits<IdRef>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::DenormPreserve:
      {
        result.data.DenormPreserve.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::DenormFlushToZero:
      {
        result.data.DenormFlushToZero.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::SignedZeroInfNanPreserve:
      {
        result.data.SignedZeroInfNanPreserve.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::RoundingModeRTE:
      {
        result.data.RoundingModeRTE.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::RoundingModeRTZ:
      {
        result.data.RoundingModeRTZ.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::OutputPrimitivesNV:
      {
        result.data.OutputPrimitivesNV.primitiveCount = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::SharedLocalMemorySizeINTEL:
      {
        result.data.SharedLocalMemorySizeINTEL.size = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::RoundingModeRTPINTEL:
      {
        result.data.RoundingModeRTPINTEL.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::RoundingModeRTNINTEL:
      {
        result.data.RoundingModeRTNINTEL.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::FloatingPointModeALTINTEL:
      {
        result.data.FloatingPointModeALTINTEL.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::FloatingPointModeIEEEINTEL:
      {
        result.data.FloatingPointModeIEEEINTEL.targetWidth = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::MaxWorkgroupSizeINTEL:
      {
        result.data.MaxWorkgroupSizeINTEL.max_x_size = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.MaxWorkgroupSizeINTEL.max_y_size = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        result.data.MaxWorkgroupSizeINTEL.max_z_size = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::MaxWorkDimINTEL:
      {
        result.data.MaxWorkDimINTEL.max_dimensions = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::NumSIMDWorkitemsINTEL:
      {
        result.data.NumSIMDWorkitemsINTEL.vector_width = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
      case ExecutionMode::SchedulerTargetFmaxMhzINTEL:
      {
        result.data.SchedulerTargetFmaxMhzINTEL.target_fmax = TypeTraits<LiteralInteger>::read(from, to, cds, error);
        if (error)
          return {};
        break;
      };
    };
    return result;
  }
};
template <>
struct TypeTraits<RayQueryCandidateIntersectionType>
{
  static const char *doc() { return ""; }
  static const char *name() { return "RayQueryCandidateIntersectionType"; }
  typedef RayQueryCandidateIntersectionType ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<MemoryModel>
{
  static const char *doc() { return ""; }
  static const char *name() { return "MemoryModel"; }
  typedef MemoryModel ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<SamplerAddressingMode>
{
  static const char *doc() { return ""; }
  static const char *name() { return "SamplerAddressingMode"; }
  typedef SamplerAddressingMode ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
template <>
struct TypeTraits<StorageClass>
{
  static const char *doc() { return ""; }
  static const char *name() { return "StorageClass"; }
  typedef StorageClass ReadType;
  static ReadType read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    if (to - from < 1)
    {
      error = true;
      return {};
    }
    ReadType result{static_cast<ReadType>(*from++)};
    return result;
  }
};
struct PairIdRefLiteralInteger
{
  IdRef first;
  LiteralInteger second;
};
template <>
struct TypeTraits<PairIdRefLiteralInteger>
{
  static const char *name() { return "PairIdRefLiteralInteger"; }
  static PairIdRefLiteralInteger read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    auto localFrom = from;
    auto c0 = TypeTraits<IdRef>::read(localFrom, to, cds, error);
    if (error)
      return {};
    auto c1 = TypeTraits<LiteralInteger>::read(localFrom, to, cds, error);
    if (error)
      return {};
    PairIdRefLiteralInteger result;
    result.first = c0;
    result.second = c1;
    from = localFrom;
    return result;
  }
};
struct PairIdRefIdRef
{
  IdRef first;
  IdRef second;
};
template <>
struct TypeTraits<PairIdRefIdRef>
{
  static const char *name() { return "PairIdRefIdRef"; }
  static PairIdRefIdRef read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    auto localFrom = from;
    auto c0 = TypeTraits<IdRef>::read(localFrom, to, cds, error);
    if (error)
      return {};
    auto c1 = TypeTraits<IdRef>::read(localFrom, to, cds, error);
    if (error)
      return {};
    PairIdRefIdRef result;
    result.first = c0;
    result.second = c1;
    from = localFrom;
    return result;
  }
};
struct PairLiteralIntegerIdRef
{
  LiteralInteger first;
  IdRef second;
};
template <>
struct TypeTraits<PairLiteralIntegerIdRef>
{
  static const char *name() { return "PairLiteralIntegerIdRef"; }
  static PairLiteralIntegerIdRef read(const Id *&from, const Id *to, Id cds, bool &error)
  {
    auto localFrom = from;
    auto c0 = TypeTraits<LiteralInteger>::read(localFrom, to, cds, error);
    if (error)
      return {};
    auto c1 = TypeTraits<IdRef>::read(localFrom, to, cds, error);
    if (error)
      return {};
    PairLiteralIntegerIdRef result;
    result.first = c0;
    result.second = c1;
    from = localFrom;
    return result;
  }
};
// enumerant name lookups
const char *name_of(SamplerFilterMode value);
const char *name_of(FunctionParameterAttribute value);
const char *name_of(ImageChannelOrder value);
const char *name_of(KernelEnqueueFlags value);
const char *name_of(RayQueryIntersection value);
const char *name_of(ImageFormat value);
const char *name_of(Scope value);
const char *name_of(LinkageType value);
const char *name_of(ImageChannelDataType value);
const char *name_of(Decoration value);
const char *name_of(QuantizationModes value);
const char *name_of(BuiltIn value);
const char *name_of(AddressingModel value);
const char *name_of(PackedVectorFormat value);
const char *name_of(Dim value);
const char *name_of(OverflowModes value);
const char *name_of(FPRoundingMode value);
const char *name_of(Capability value);
const char *name_of(GroupOperation value);
const char *name_of(ExecutionModel value);
const char *name_of(AccessQualifier value);
const char *name_of(RayQueryCommittedIntersectionType value);
const char *name_of(SourceLanguage value);
const char *name_of(FPDenormMode value);
const char *name_of(ExecutionMode value);
const char *name_of(FPOperationMode value);
const char *name_of(RayQueryCandidateIntersectionType value);
const char *name_of(MemoryModel value);
const char *name_of(SamplerAddressingMode value);
const char *name_of(StorageClass value);
} // namespace spirv
